<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Baseball HR/G and BA Line Charts</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://rawgit.com/susielu/d3-annotation/master/d3-annotation.min.js"></script>
</head>
<body>
  <div id="context-section"></div>
  <div id="linechart-container"></div>
    <div id="chart-selector" style="display: none;">
    <label for="chart-type"  id="chart-type-label">Select Chart:</label>
    <select id="chart-type">
      <option value="hr">HR/Game</option>
      <option value="ba">Batting Average</option>
    </select>
  </div>
  <button id="next-button">Next Chart</button>

  <script>
    
    const svgWidth = window.innerWidth;
    const svgHeight = window.innerHeight;
    const margin = { top: 50, right: 50, bottom: 70, left: 70 };
    const width = svgWidth - margin.left - margin.right;
    const height = svgHeight - margin.top - margin.bottom;
    const dataUrl = "https://raw.githubusercontent.com/UofI-Ryan-Kupiec/UofI-Ryan-Kupiec.github.io/main/Baseball_Hitting_Historic_Data.csv";

    const svg = d3.select("#linechart-container")
      .append("svg")
      .attr("width", svgWidth)
      .attr("height", svgHeight);

    d3.select("#next-button")
      .style("position", "absolute")
      .style("top", "50%")
      .style("right", "20px")
      .style("padding", "12px 20px") 
      .style("font-size", "16px");

    function drawLineChart1(data, scene_num, lastChart = false) {
      d3.select("#context-section").html("");
      const contextSection = d3.select("#context-section")

      contextSection.append("h1")
        .style("text-align", "center")
        .style("font-size", "40px")
        .text("Overview");

      contextSection.append("p")
        .style("text-align", "center")  
        .style("font-size", "22px")
        .text("Over the last decade baseball has seen a change unlike any stretch seen in sports history. Statistics has taken over the game and caused major changes to the way the game is played. Not all of these changes in play have been good for the game. As seen in this chart, one major change we have seen in the last few years is a staggering increase in the homerun rate.");

      contextSection.append("p")
        .style("text-align", "center")  
        .style("font-size", "22px")
        .text("Please select the Next Chart button on the right when finished with this page!");
      
      const svg = d3.select("#linechart-container svg");
      svg.html("");

      const xScale = d3.scaleTime()
        .domain(d3.extent(data, function(d) { return d.Year; }))
        .range([margin.left, width - margin.right]);

      const yScale = d3.scaleLinear()
        .domain(d3.extent(data, function(d) { return d['HR/G']; }))
        .range([height - margin.bottom, margin.top]);

     const xAxis = svg.append("g")
        .attr("transform", `translate(0, ${height - margin.bottom})`)
        .call(d3.axisBottom(xScale).ticks(d3.timeYear.every(10)));

      svg.append("g")
        .attr("transform", `translate(${margin.left}, 0)`)
        .call(d3.axisLeft(yScale));
      
    const clip = svg.append("defs").append("svg:clipPath")
        .attr("id", "clip")
        .append("svg:rect")
        .attr("width", width - margin.left - margin.right) 
        .attr("height", height - margin.top - margin.bottom) 
        .attr("x", margin.left) 
        .attr("y", margin.top); 

    const brush = d3.brushX()                   
        .extent( [ [0,0], [width,height] ] )  
        .on("end", updateChart)               
       
const line = svg.append('g')
       .attr("clip-path", "url(#clip)")
    
    // Add the line
    line.append("path")
      .datum(data)
      .attr("class", "line")  // I add the class line to be able to modify this line later on.
      .attr("fill", "none")
      .attr("stroke", "blue")
      .attr("stroke-width", 2)
      .attr("d", d3.line()
        .x(d => xScale(d.Year))
        .y(d => yScale(d['HR/G']))
        )

    if(lastChart){
    line
      .append("g")
        .attr("class", "brush")
        .call(brush);
    }

      svg.append("text")
        .attr("x", width / 2)
        .attr("y", height - margin.bottom / 2)
        .attr("text-anchor", "middle")
        .text("Year");

      svg.append("text")
        .attr("transform", "rotate(-90)")
        .attr("x", -height / 2)
        .attr("y", margin.left / 2)
        .attr("text-anchor", "middle")
        .text("HR/G (Home Runs per Game)");

      svg.append("text")
        .attr("x", width / 2)
        .attr("y", margin.top / 2)
        .attr("text-anchor", "middle")
        .style("font-size", "1.5em")
        .text("Home Runs per Game over Time");




      
       // A function that set idleTimeOut to null
    let idleTimeout
    function idled() { idleTimeout = null; }

  function updateChart(event) {
    // UPDATE: What are the selected boundaries?
    const extent = event.selection;

    // If no selection, back to initial coordinate. Otherwise, update X axis domain
    if (!extent) {
      if (!idleTimeout) return idleTimeout = setTimeout(idled, 350); // This allows waiting a little bit
      xScale.domain(d3.extent(data, function(d) { return d.Year; }));
    } else {
      xScale.domain([xScale.invert(extent[0]), xScale.invert(extent[1])]);
      line.select(".brush").call(brush.move, null); // This removes the grey brush area as soon as the selection has been done
    }

    xAxis.transition().duration(1000).call(d3.axisBottom(xScale));
    line.select('.line')
      .transition()
      .duration(1000)
      .attr("d", d3.line()
        .x(d => xScale(d.Year))
        .y(d => yScale(d['HR/G']))
      );
  }

  xAxis.transition().duration(1000).call(d3.axisBottom(xScale));
  line.select('.line')
    .transition()
    .duration(1000)
    .attr("d", d3.line()
      .x(d => xScale(d.Year))
      .y(d => yScale(d['HR/G']))
    );

  // If user double clicks, reinitialize the chart
  svg.on("dblclick", function() {
    xScale.domain(d3.extent(data, function(d) { return d.Year; }));
    xAxis.transition().call(d3.axisBottom(xScale));
    line.select('.line')
      .transition()
      .attr("d", d3.line()
        .x(d => xScale(d.Year))
        .y(d => yScale(d['HR/G']))
      );
  });      


      
      if(scene_num == 2){
        d3.select("#context-section").html("");
        const contextSection = d3.select("#context-section")
  
        contextSection.append("h1")
          .style("text-align", "center")
          .style("font-size", "40px")
          .text("Overview");
  
        contextSection.append("p")
          .style("text-align", "center")  
          .style("font-size", "22px")
          .text("This new 'arms race' of data analysis was widely adopted by the league beginning in 2015 all teams began tracking advanded metrics using statcast. This new addition of advanced metrics highlighted what teams should value and as a result caused players to focus on the top metrics that would lead to larger contracts. This drove players to focus less on making contact frequently and more on making hard contact and getting the ball in there. This new prioirty explains this large spike in homeruns per game.");
        
        const highlightStart = new Date(2014, 0, 1);
        const highlightEnd = new Date(2023, 0, 1);
      
        const annotationGroup = svg.append("g") 
          .attr("class", "annotation")
          .style("pointer-events", "none");
      
        const dataPoints = data.filter(d => d.Year >= highlightStart && d.Year <= highlightEnd);
        const yPos = yScale(d3.max(dataPoints, d => d['HR/G']));

    const annotations = [{
      type: d3.annotationCalloutCircle,
      note: {
        label: "Statcast Era",
        title: "2015-2023"
      },
      subject: {
            radius: xScale(new Date(2023, 0, 1)) - xScale(new Date(2015, 0, 1))
          },
    x: xScale(new Date(2015, 0, 1)), // Start date
    y: yScale(data.find(d => d.Year.getFullYear() === 2023)['HR/G']),
    dy: 50,
    dx: 0
    }
  ];

  const makeAnnotations = d3.annotation()
    .annotations(annotations);

  svg.append("g")
    .call(makeAnnotations);
    }

        
        /*
        annotationGroup.append("rect")
          .attr("x", xScale(highlightStart))
          .attr("y", margin.top) // yPos
          .attr("width", xScale(highlightEnd) - xScale(highlightStart))
          .attr("height", height - margin.bottom - margin.top) // - yPos
          .attr("fill", "yellow")
          .attr("opacity", 0.3);
  
      annotationGroup.append("text")
        .attr("x", (xScale(highlightStart) + xScale(highlightEnd)) / 2)
        .attr("y", xScale(highlightStart)) // Adjust the y position to place the text above the arrow
        .attr("text-anchor", "middle")
        .style("font-size", "16px")
        .text("Years 2014-2023: Explanation for these highlighted years");
      }
      */
    }

    function drawLineChart2(data, lastChart = false) {
      const filteredData = data.filter(d => d.Year >= new Date(2014, 0, 1) && d.Year <= new Date(2023, 0, 1));
      
      d3.select("#context-section").html("");

      const contextSection = d3.select("#context-section")

      contextSection.append("h1")
          .style("text-align", "center")
          .style("font-size", "40px")
          .text("Statcast Era");
  
      contextSection.append("p")
          .style("text-align", "center")  
          .style("font-size", "22px")
          .text("This jump in homeruns per game caused many investigations by the league into whether the balls were 'juiced'. A thorough investigation found that 40% of the increase in homeruns in 2019 was due to play behavior changing. Players began trying to swing harder and hit the ball higher with the hopes of hitting more homeruns. This lead to less balls being put in play. The MLB has a reputation as a boring sport and less balls in play means less action and as a result less interest from casual fans. The MLB has put many ");
      
      const svg = d3.select("#linechart-container svg");
    
      svg.html("");

      const xScale = d3.scaleTime()
        .domain(d3.extent(filteredData, function(d) { return d.Year; }))
        .range([margin.left, width - margin.right]);

      const yScale = d3.scaleLinear()
        .domain(d3.extent(filteredData, function(d) { return d['HR/G']; }))
        .range([height - margin.bottom, margin.top]);

      const xAxis = svg.append("g")
        .attr("transform", `translate(0, ${height - margin.bottom})`)
        .call(d3.axisBottom(xScale).ticks(d3.timeYear.every(1)));

      svg.append("g")
        .attr("transform", `translate(${margin.left}, 0)`)
        .call(d3.axisLeft(yScale));

      const line = d3.line()
        .x(d => xScale(d.Year))
        .y(d => yScale(d['HR/G']));

      svg.append("path")
        .datum(filteredData)
        .attr("fill", "none")
        .attr("stroke", "blue")
        .attr("stroke-width", 2)
        .attr("d", line);

      svg.append("text")
        .attr("x", width / 2)
        .attr("y", height - margin.bottom / 2)
        .attr("text-anchor", "middle")
        .text("Year");

      svg.append("text")
        .attr("transform", "rotate(-90)")
        .attr("x", -height / 2)
        .attr("y", margin.left / 2)
        .attr("text-anchor", "middle")
        .text("HR/G (Home Runs per Game)");

      svg.append("text")
        .attr("x", width / 2)
        .attr("y", margin.top / 2)
        .attr("text-anchor", "middle")
        .style("font-size", "1.5em")
        .text("Home Runs per Game from 2014-2023");

      const annotations = [
    {
      note: {
        label: "2015: HR/Game ballon from 0.86 in 2014 to 1.01 in 2015",
        title: "2015"
      },
      x: xScale(new Date(2015, 0, 1)),
      y: yScale(filteredData.find(d => d.Year.getFullYear() === 2015)['HR/G']),
      dy: -50,
      dx: 0
    },
    {
      note: {
        label: "2019: HR/Game record is broken at 1.39 HR/Game. MLB research finds that 40% of the change in HR/Game is player behavior changes.",
        title: "2019"
      },
      x: xScale(new Date(2019, 0, 1)),
      y: yScale(filteredData.find(d => d.Year.getFullYear() === 2019)['HR/G']),
      dy: 150,
      dx: 0
    },
    {
      note: {
        label: "2021: MLB warns teams to expect a less lively ball. A lighter ball designed to carry less was deployed.",
        title: "2021"
      },
      x: xScale(new Date(2021, 0, 1)),
      y: yScale(filteredData.find(d => d.Year.getFullYear() === 2021)['HR/G']),
      dy: -50,
      dx: 0
    },
    {
      note: {
        label: "2022: MLB stores baseballls in all 30 stadiums in humidors to stop the ball from drying up since that causes the ball to carry more.",
        title: "2022"
      },
      x: xScale(new Date(2022, 0, 1)),
      y: yScale(filteredData.find(d => d.Year.getFullYear() === 2022)['HR/G']),
      dy: -100,
      dx: 0
    },
    {
      type: d3.annotationCalloutCircle,
      note: {
        label: "2023: MLB bans the shift in an effort to encourage more balls to be hit in play. Base sizes are increased to try to revive stealing bases to also encourage getting on base more often.",
        title: "2022"
      },
      subject: {
            radius: 10
          },
      x: xScale(new Date(2023, 0, 1)),
      y: yScale(filteredData.find(d => d.Year.getFullYear() === 2023)['HR/G']),
      dy: 50,
      dx: 0
    }
  ];

  const makeAnnotations = d3.annotation()
    .type(d3.annotationLabel)
    .annotations(annotations);

  svg.append("g")
    .attr("class", "annotation-group")
    .call(makeAnnotations);
    }


    // BATTING AVERAGE CHART
    function drawLineChart3(data, lastChart = false) {
      let filteredData;
      if(!lastChart){
        filteredData = data.filter(d => d.Year >= new Date(1998, 0, 1) && d.Year <= new Date(2023, 0, 1));
      }else{
        filteredData = data
      }
      
      const svg = d3.select("#linechart-container svg");
      // Clear the contents of the SVG container
      svg.html("");

      // Setup scales and axes for the second chart
      const xScale = d3.scaleTime()
        .domain(d3.extent(filteredData, function(d) { return d.Year; }))
        .range([margin.left, width - margin.right]);

      const yScale = d3.scaleLinear()
        .domain(d3.extent(filteredData, function(d) { return d['BA']; }))
        .range([height - margin.bottom, margin.top]);

      const xAxis = svg.append("g")
        .attr("transform", `translate(0, ${height - margin.bottom})`)
        .call(d3.axisBottom(xScale).ticks(d3.timeYear.every(1)));

      svg.append("g")
        .attr("transform", `translate(${margin.left}, 0)`)
        .call(d3.axisLeft(yScale));

    const clip = svg.append("defs").append("svg:clipPath")
        .attr("id", "clip")
        .append("svg:rect")
        .attr("width", width - margin.left - margin.right) 
        .attr("height", height - margin.top - margin.bottom) 
        .attr("x", margin.left) 
        .attr("y", margin.top); 

    const brush = d3.brushX()                   
        .extent( [ [0,0], [width,height] ] )  
        .on("end", updateChart)               
       
const line = svg.append('g')
       .attr("clip-path", "url(#clip)")
    
    // Add the line
    line.append("path")
      .datum(filteredData)
      .attr("class", "line")  // I add the class line to be able to modify this line later on.
      .attr("fill", "none")
      .attr("stroke", "blue")
      .attr("stroke-width", 2)
      .attr("d", d3.line()
        .x(d => xScale(d.Year))
        .y(d => yScale(d['BA']))
        )

    if(lastChart){
    line
      .append("g")
        .attr("class", "brush")
        .call(brush);
    }

      svg.append("text")
        .attr("x", width / 2)
        .attr("y", height - margin.bottom / 2)
        .attr("text-anchor", "middle")
        .text("Year");

      svg.append("text")
        .attr("transform", "rotate(-90)")
        .attr("x", -height / 2)
        .attr("y", margin.left / 2)
        .attr("text-anchor", "middle")
        .text("Batting Average");

      svg.append("text")
        .attr("x", width / 2)
        .attr("y", margin.top / 2)
        .attr("text-anchor", "middle")
        .style("font-size", "1.5em")
        .text("Batting Average Over The Last 25 Years");

      // Shift began
      // Shift was banned; pitch clocks added
      //statcast introduced 
      // DH in both leagues 2020

      
       // A function that set idleTimeOut to null
    let idleTimeout
    function idled() { idleTimeout = null; }

  function updateChart(event) {
    // UPDATE: What are the selected boundaries?
    const extent = event.selection;

    // If no selection, back to initial coordinate. Otherwise, update X axis domain
    if (!extent) {
      if (!idleTimeout) return idleTimeout = setTimeout(idled, 350); // This allows waiting a little bit
      xScale.domain(d3.extent(filteredData, function(d) { return d.Year; }));
    } else {
      xScale.domain([xScale.invert(extent[0]), xScale.invert(extent[1])]);
      line.select(".brush").call(brush.move, null); // This removes the grey brush area as soon as the selection has been done
    }

    xAxis.transition().duration(1000).call(d3.axisBottom(xScale));
    line.select('.line')
      .transition()
      .duration(1000)
      .attr("d", d3.line()
        .x(d => xScale(d.Year))
        .y(d => yScale(d['BA']))
      );
  }

  xAxis.transition().duration(1000).call(d3.axisBottom(xScale));
  line.select('.line')
    .transition()
    .duration(1000)
    .attr("d", d3.line()
      .x(d => xScale(d.Year))
      .y(d => yScale(d['BA']))
    );

  // If user double clicks, reinitialize the chart
  svg.on("dblclick", function() {
    xScale.domain(d3.extent(filteredData, function(d) { return d.Year; }));
    xAxis.transition().call(d3.axisBottom(xScale));
    line.select('.line')
      .transition()
      .attr("d", d3.line()
        .x(d => xScale(d.Year))
        .y(d => yScale(d['BA']))
      );
  });      
    }

    // LAST CHART + USER INTERACTION
     function drawLineChart4(data) {
      d3.select("#context-section").html("");
      const contextSection = d3.select("#context-section")

      contextSection.append("h1")
        .style("text-align", "center")
        .style("font-size", "40px")
        .text("Conclusion");

      contextSection.append("p")
        .style("text-align", "center")  
        .style("font-size", "22px")
        .text("That is the end of the slide show. Feel free to explore further if there were any additional trends you wanted to look into!");

       // Remove next button
      d3.select("#next-button").style("display", "none")

       // add chart selector dropdown
      d3.select("#chart-selector")
      .style("display", "block")
      .style("position", "absolute")
      .style("top", "50%")
      .style("right", "20px")
      .style("padding", "12px 20px") 
      .style("font-size", "16px");

       d3.select("#chart-type-label")
        .style("display", "block")
        .style("text-align", "center")
        .style("font-size", "16px");
       
       const svg = d3.select("#linechart-container svg");
       svg.html("");
       
      const xScale = d3.scaleTime()
        .domain(d3.extent(data, function(d) { return d.Year; }))
        .range([margin.left, width - margin.right]);

      const yScale = d3.scaleLinear()
        .domain(d3.extent(data, function(d) { return d['HR/G']; }))
        .range([height - margin.bottom, margin.top]);

       const xAxis = svg.append("g")
        .attr("transform", `translate(0, ${height - margin.bottom})`)
        .call(d3.axisBottom(xScale).ticks(d3.timeYear.every(10)));

      svg.append("g")
        .attr("transform", `translate(${margin.left}, 0)`)
        .call(d3.axisLeft(yScale));

    const clip = svg.append("defs").append("svg:clipPath")
        .attr("id", "clip")
        .append("svg:rect")
        .attr("width", width - margin.left - margin.right) 
        .attr("height", height - margin.top - margin.bottom) 
        .attr("x", margin.left) 
        .attr("y", margin.top); 

    const brush = d3.brushX()                   
        .extent( [ [0,0], [width,height] ] )  
        .on("end", updateChart)               
       
const line = svg.append('g')
       .attr("clip-path", "url(#clip)")
    
    // Add the line
    line.append("path")
      .datum(data)
      .attr("class", "line")  // I add the class line to be able to modify this line later on.
      .attr("fill", "none")
      .attr("stroke", "blue")
      .attr("stroke-width", 2)
      .attr("d", d3.line()
        .x(d => xScale(d.Year))
        .y(d => yScale(d['HR/G']))
        )

    // Add the brushing
    line
      .append("g")
        .attr("class", "brush")
        .call(brush);

      svg.append("text")
        .attr("x", width / 2)
        .attr("y", height - margin.bottom / 2)
        .attr("text-anchor", "middle")
        .text("Year");

      svg.append("text")
        .attr("transform", "rotate(-90)")
        .attr("x", -height / 2)
        .attr("y", margin.left / 2)
        .attr("text-anchor", "middle")
        .text("HR/G (Home Runs per Game)");

      svg.append("text")
        .attr("x", width / 2)
        .attr("y", margin.top / 2)
        .attr("text-anchor", "middle")
        .style("font-size", "1.5em")
        .text("Home Runs per Game over Time");

      d3.select("#chart-type").on("change", function() {
          const selectedChart = this.value;
          drawSelectedChart(data, selectedChart);
      });

    // A function that set idleTimeOut to null
    let idleTimeout
    function idled() { idleTimeout = null; }

  function updateChart(event) {
    // UPDATE: What are the selected boundaries?
    const extent = event.selection;

    // If no selection, back to initial coordinate. Otherwise, update X axis domain
    if (!extent) {
      if (!idleTimeout) return idleTimeout = setTimeout(idled, 350); // This allows waiting a little bit
      xScale.domain(d3.extent(data, function(d) { return d.Year; }));
    } else {
      xScale.domain([xScale.invert(extent[0]), xScale.invert(extent[1])]);
      line.select(".brush").call(brush.move, null); // This removes the grey brush area as soon as the selection has been done
    }

    xAxis.transition().duration(1000).call(d3.axisBottom(xScale));
    line.select('.line')
      .transition()
      .duration(1000)
      .attr("d", d3.line()
        .x(d => xScale(d.Year))
        .y(d => yScale(d['HR/G']))
      );
  }

  xAxis.transition().duration(1000).call(d3.axisBottom(xScale));
  line.select('.line')
    .transition()
    .duration(1000)
    .attr("d", d3.line()
      .x(d => xScale(d.Year))
      .y(d => yScale(d['HR/G']))
    );

  // If user double clicks, reinitialize the chart
  svg.on("dblclick", function() {
    xScale.domain(d3.extent(data, function(d) { return d.Year; }));
    xAxis.transition().call(d3.axisBottom(xScale));
    line.select('.line')
      .transition()
      .attr("d", d3.line()
        .x(d => xScale(d.Year))
        .y(d => yScale(d['HR/G']))
      );
  });      
}

    // CHART SELECTION FUNCTION
    function drawSelectedChart(data, chartType) {
      d3.select("#context-section").html("");

      if (chartType === "hr") {
        drawLineChart1(data, 1, lastChart = true);
        d3.select("#context-section").html("");
        const contextSection = d3.select("#context-section")

        contextSection.append("h1")
          .style("text-align", "center")
          .style("font-size", "40px")
          .text("Conclusion");

        contextSection.append("p")
          .style("text-align", "center")  
          .style("font-size", "22px")
          .text("That is the end of the slide show. Feel free to explore further if there were any additional trends you wanted to look into!");

      } else if (chartType === "ba") {
        drawLineChart3(data, lastChart = true);
        d3.select("#context-section").html("");
        const contextSection = d3.select("#context-section")

        contextSection.append("h1")
          .style("text-align", "center")
          .style("font-size", "40px")
          .text("Conclusion");

        contextSection.append("p")
          .style("text-align", "center")  
          .style("font-size", "22px")
          .text("That is the end of the slide show. Feel free to explore further if there were any additional trends you wanted to look into!");

      }
    }

    // Initialize the scene number to 1 (first chart)
    let currentScene = 1;

    // Attach a click event listener to the "Next" button
    d3.select("#next-button").on("click", function() {
      svg.selectAll(".annotation").remove();
      // Increment the current scene number
      currentScene++;

      // Fetch data from the CSV file and draw the appropriate chart
      d3.csv(dataUrl, function(d) {
        return {
          Year: d3.timeParse('%Y')(d.Year.toString()),
          'HR/G': +d['HR/G'],
          'BA': +d['BA']
        };
      }).then(function(data) {
        if (currentScene === 1 || currentScene === 2) {
          drawLineChart1(data, currentScene); // Draw the first chart
        } else if (currentScene === 3) {
          drawLineChart2(data); // Draw the second chart
        } else if (currentScene === 4) {
          drawLineChart3(data); // Draw the second chart
        }else {
          drawLineChart4(data); // Draw the second chart
        }
      });
    });

    // Fetch data from the CSV file and draw the initial chart
    d3.csv(dataUrl, function(d) {
      return {
        Year: d3.timeParse('%Y')(d.Year.toString()),
        'HR/G': +d['HR/G'],
        'BA': +d['BA']
      };
    }).then(function(data) {
      drawLineChart1(data); // Draw the initial chart with the first set of data
    });


    
  </script>
</body>
</html>
